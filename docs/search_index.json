[["index.html", "A laboratory manual for quantitative genetics Chapter 1 Genetic constitution of a population", " A laboratory manual for quantitative genetics James Webb, PhD 2024-03-05 Chapter 1 Genetic constitution of a population "],["linkage-disequilibrium.html", "Chapter 2 Linkage disequilibrium 2.1 Introduction 2.2 Getting started 2.3 Development of the populations 2.4 Un-linked loci 2.5 Closely linked loci 2.6 Conclusion", " Chapter 2 Linkage disequilibrium 2.1 Introduction When considered independently, individual loci can reach equilibrium after one generation of random breeding. However, when considered jointly, the number of generations needed for two or more loci to reach equilibrium depends on the recombination frequency, and as such, the physical map positions of the loci themselves. Here, a brief genetic simulation is performed to demonstrate the relationship between physical map position, recombination frequency, and linkage disequilibrium. 2.2 Getting started AlphaSimR was used to perform the simulation. Tidyverse tools were used for general data wrangling, manipulation, and plotting. library(AlphaSimR) library(flextable) library(tidyverse) set_flextable_defaults(fonts_ignore=TRUE) 2.3 Development of the populations Highly simplified genomes were simulated to observe the interaction between physical map location, recombination frequency, and linkage disequilibrium. The populations are generally based on ‘end of chapter’ problem 1.10. Individuals possess a single chromosome of 1 Morgan in length. The chromosome consists of 10 segregation sites with loci spaced 0.1 Morgans apart. Two distinct populations were made. pop_ABC is homozygous for all 1 alleles and pop_abc is homozygous for all 0 alleles. 1000 haplotypes, or 500 diploid individuals, were simulated for each population. Sexes were set systematically such that each population consists of 250 females and 250 males. The code specifying each population and the genetic map of a representative individual are shown below. Rows in the genetic maps specify the two gamete possibilities of individuals 1 and 501. Columns specify each of the 10 loci of the single chromosome genome of the individuals. pop_ABC &lt;- newMapPop(genMap = list(seq(0, 1, length.out = 10)), haplotypes = list(matrix(0, nrow = 1000, ncol = 10))) SP &lt;- SimParam$new(pop_ABC) SP &lt;- SP$setSexes(&quot;yes_sys&quot;) pop_ABC &lt;- newPop(rawPop = pop_ABC, simParam = SP) .cl-e136cbe4{}.cl-e11fa20c{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e129e3fc{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e12a3afa{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e12a3b18{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e12a3b22{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e12a3b23{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e12a3b2c{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e12a3b36{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}Ind/Haploc_01loc_02loc_03loc_04loc_05loc_06loc_07loc_08loc_09loc_101_100000000001_20000000000 pop_abc &lt;- newMapPop(genMap = list(seq(0, 1, length.out = 10)), haplotypes = list(matrix(1, nrow = 1000, ncol = 10))) pop_abc &lt;- newPop(rawPop = pop_abc, simParam = SP) .cl-e199a8cc{}.cl-e1830da6{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e18c5dac{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e18cb766{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e18cb784{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e18cb78e{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e18cb7a2{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e18cb7ac{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e18cb7ad{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}Ind/Haploc_01loc_02loc_03loc_04loc_05loc_06loc_07loc_08loc_09loc_10501_11111111111501_21111111111 After specifying the two populations they were merged and crossed into a single ‘founder’ population. The function randCross was specified to perform 500 crosses each producing two offspring. This ‘idealized’ scenario results in 1000 offspring, the same number as the parent generation. Because the crosses are done at random and there are both females and males homozygous for both alleles, the founder population is a mixture of homozygous and heterozygous individuals. POP_m &lt;- mergePops(list(pop_ABC, pop_abc)) POP_f &lt;- randCross(pop = POP_m, nCrosses = 500, nProgeny = 2, balance = TRUE, parents = NULL, simParam = SP) With the founder population specified 30 generations of random mating were simulated. First, a vector in the form of a list was made to a length of generations + 1. The founder population was then added as the first entry of the list. Next, a for loop was created to walk forward the generations using the randCross() function. As performed for the founders, each generation ‘replaced’ the 1000 individuals of the previous generation through 500 crosses, each resulting in two full sibs. Each population was stored sequentially in the vector POP. POP &lt;- vector(length = 31, mode = &quot;list&quot;) POP[[1]] &lt;- POP_f for (i in 2:31) { POP[[i]] &lt;- randCross(pop = POP[[i - 1]], nCrosses = 500, nProgeny = 2, balance = TRUE, parents = NULL, simParam = SP) } With all the populations stored, the haplotypes were needed for the analysis. A function was created acquire the happlotypes from each generation, add a few qualifiers, and wrangle them into a data frame for row binding and downstream analysis. At its core is the pullSegSiteHaplo() function which produces an ‘individual + haplotype’ x ‘chromosome + segregation site’ matrix. Here, the segregation sites were first renamed. The ‘individual + haplotype’ rownames were then made into separate columns. Finally, the generation number was added such that the founders were considered generation 0. Once the function was created, lapply was used to create a data frame for each of the 30 generations simulated. By placing the lapply under the command of rbind within do.call, the 30 data frames were returned as a single data frame. F_haps &lt;- function(gen){ data.frame(pullSegSiteHaplo(pop = POP[[gen]], haplo = &quot;all&quot;)) %&gt;% rename_with(~paste(&#39;loc&#39;, str_pad(1:10, 2, pad = &quot;0&quot;), sep = &#39;_&#39;)) %&gt;% rownames_to_column(&#39;IG&#39;) %&gt;% separate(IG, c(&#39;IND&#39;, &#39;HAP&#39;), &#39;_&#39;) %&gt;% mutate(GEN = gen - 1) } df_haps &lt;- do.call(rbind, lapply(1:31, FUN = F_haps)) 2.4 Un-linked loci With the haplotypes in order, we first looked at two loci that should be un-linked, or in ‘linkage equilibrium’. Loci 2 and 9 were chosen as an example. If we recall from introductory genetics, rather than being a measure of physical distance (NB: base pairs), Morgans are a measure of recombination frequency. As such, the Morgans in which the simulated genome was developed are equivalent to the recombination frequency variable ‘c’ in the text. If we recall from the text, recombination frequencies have a maximum value of 0.5. At this value, the loci are un-linked and segregate as if on separate chromosomes. Loci 2 and 9 are 0.7 Morgans distant from one another and as such should exhibit a recombination frequency approaching 0.5. The exercise was designed to be repeated by simply specifying different loci as shown below. All loci combinations greater than 0.5 Morgans distant from one another should exhibit recombination frequencies near to 0.5. loc_A &lt;- &#39;loc_02&#39; loc_B &lt;- &#39;loc_09&#39; With the loci specified, take a close look at the following code. We start with the haplotypes data frame and select only the generation and specified loci columns. We then grouped the data by generation and summarized the gene frequencies of the specified loci. Because alleles are labeled as 0s and 1s the frequency of the 1 allele can be achieved by summing all rows and dividing by the total number of rows. The across function was used here to perform the operation on all columns (other than the grouping column). This simply makes the script adaptable to other loci combinations. Once the 1 allele frequencies were calculated for each generation, they were designated as pA (0) and pB (1) to conform with table 1.5 from the text. qA and qB were then calculated with the knowledge that p + q = 1. With the gene frequencies calculated, r, s, t, and u equilibrium frequencies were calculated according to table 1.5. The first few generations of the data frame are shown for reference. df_haps_1 &lt;- df_haps %&gt;% select(GEN, loc_A, loc_B) %&gt;% group_by(GEN) %&gt;% summarise(across(where(is.numeric), sum)/n()) %&gt;% mutate(pA = 1 - !!as.name(loc_A), qA = !!as.name(loc_A)) %&gt;% mutate(pB = 1 - !!as.name(loc_B), qB = !!as.name(loc_B)) %&gt;% select(GEN, pA, qA, pB, qB) %&gt;% mutate(r_eq = pA * pB, s_eq = pA * qB, t_eq = qA * pB, u_eq = qA * qB) %&gt;% round(., 2) .cl-e43892b4{}.cl-e4160e38{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e4233158{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e42390da{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e4239102{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e423910c{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}GENpAqApBqBr_eqs_eqt_equ_eq00.500.500.50.50.250.250.250.2510.510.490.50.50.260.260.240.2420.520.480.50.50.260.260.240.2430.520.480.50.50.260.260.240.2440.530.470.50.50.270.270.230.2350.530.470.50.50.260.270.230.24 If we look at the data we see that each row is a generation and we now have the gene frequencies of both alleles for the two loci and the their expected equilibrium gamete frequencies. If we again turn to table 1.5 we find that rows 2 and 4 have been calculated. The main difference being that we have done this for 30 generations rather than just 1. It is a bit cumbersome in ‘wide format’ but useful to visualizing each step in the calculations. The following script continues by first adding rows 5, the actual gametic frequencies, to the table. The differences from equilibrium (row 6) are then determined before calculating both D and Dmax. A more thorough description is provided below . df_haps_2 &lt;- df_haps %&gt;% select(GEN, loc_A, loc_B) %&gt;% mutate(GAM_gt = case_when(!!as.name(loc_A) == 0 &amp; !!as.name(loc_B) == 0 ~ &#39;r&#39;, !!as.name(loc_A) == 0 &amp; !!as.name(loc_B) == 1 ~ &#39;s&#39;, !!as.name(loc_A) == 1 &amp; !!as.name(loc_B) == 0 ~ &#39;t&#39;, !!as.name(loc_A) == 1 &amp; !!as.name(loc_B) == 1 ~ &#39;u&#39;)) %&gt;% group_by(GEN, GAM_gt) %&gt;% summarize(FREQ_obs = n() / 2000) %&gt;% group_by(GEN) %&gt;% spread(key = GAM_gt, value = FREQ_obs) %&gt;% replace(is.na(.), 0) %&gt;% merge(., df_haps_1, by = &#39;GEN&#39;) %&gt;% select(GEN, pA, qA, pB, qB, r_eq, s_eq, t_eq, u_eq, r, s, t, u) %&gt;% mutate(Dr = r - r_eq, Ds = s - s_eq, Dt = t - t_eq, Du = u - u_eq) %&gt;% mutate(D = (r*u) - (s*t)) %&gt;% mutate(Dmax = ifelse(s_eq &lt;= t_eq, D / s_eq, D / t_eq)) %&gt;% round(., 2) .cl-e4c165da{}.cl-e4a071cc{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e4acce54{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e4ad110c{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e4ad1120{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e4ad112a{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}GENrstuDrDsDtDuDDmax00.500.000.000.500.25-0.25-0.250.250.251.0010.380.130.110.370.12-0.13-0.130.130.130.5420.330.190.170.310.07-0.07-0.070.070.070.2930.290.240.210.270.03-0.02-0.030.030.030.1140.290.240.210.260.02-0.03-0.020.030.020.1050.270.260.230.250.01-0.010.000.010.010.03 The code is a bit complicated, especially if your new to R programming. It begins with the haplotype data frame and again we selected only generation and the two loci of interest. A column denoting actual gametic types, or gam_gt was then added be defining a number of ‘cases’. The cases relate to an individual’s combination of alleles at the specified loci. For example, 0 at loc_A and 0 at loc_B equates to ‘r’. The designations correspond to the gametic type in row 3 of table 1.5. With r, s, t, and u specified the data was grouped by generation and gametic type to determine the frequency of gametic types in each generation. This was performed by simply taking the number of each type and dividing by 2000, as there were 4 gametic types x 500 individual in each generation. NA values were replaced with 0s and the data frame was converted to wide for merging with the gene and gametic equilibrium frequencies. The select function was used again to get everything in the right order for presentation. The disequilibrium was then determined for each gametic type, and the total disequilibrium calculated using the equation D = ru - st. In calculating Dmax, values are normalized to the lesser of the repulsion heterozygote equilibroum frequencies. In this way, the largest possible value of D is achieved. The values also correspond to figure 1.3 and equation 1.5. The following code applies the simulated data to both the equation and the figure. First, the nls function is used to fit equation 1.5 to the data. Then Dmax as a function of generation is plotted graphically. Actual data is shown in points, and modeled data as a line. A summary of the model is also provided to observe the fit and predict recombination frequency (c). mod_unlinked &lt;- nls(Dmax ~ 1 * (1 - c)^GEN, data = df_haps_2, start = list(c = 0.5)) df_haps_2 %&gt;% ggplot() + geom_line(aes(x = GEN, y = predict(mod_unlinked)), size = 1, color = &#39;grey&#39;) + geom_point(aes(x = GEN, y = Dmax), color = &#39;blue&#39;) + xlab(&#39;generations&#39;) + ylab(&#39;disequilibrium&#39;) + scale_x_continuous(breaks = seq(0, 30, by = 1)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + theme_bw() ## Warning: Using `size` aesthetic for lines was deprecated in ## ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see ## where this warning was generated. The plot of disequilibrium as a function of generation looks very similar to the c = 0.5 series of figure 1.3 in the text. When presented as Dmax, disequilibrium is 1 in generation 0 and then declines sharply. After 5-6 generations equilibrium has been reached and Dmax oscillates around 0. The slight oscillation is error as a result of the data being determined from simulated genomes and populations. The error can actually be increased/decreased through increases/decreases to the population size. This, however, is a topic of importance for later chapters. summary(mod_unlinked) ## ## Formula: Dmax ~ 1 * (1 - c)^GEN ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## c 0.46524 0.01515 30.72 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.02846 on 30 degrees of freedom ## ## Number of iterations to convergence: 3 ## Achieved convergence tolerance: 5.823e-06 We can see from the gray line that despite some error, the model is a good fit for our points. In the summary, we can confirm that it was a ‘highly significant’ fit. We can also clearly see that the equation is the same as equation 1.5 from the text. For this exercise, we are also interested in the calculated value of c, the recombination frequency. Here, we find it to be ~ 0.465 which while not exactly 0.5 is suggestive of two ‘nearly un-linked’ loci. 2.5 Closely linked loci After fair success observing un-linked loci, we can now turn our attention to loci in close proximity to one another. For this example, Loci 2 and 3 were chosen but the code was written to try out other combinations. Based on the map of our simulated genome, loci 2 and 3 are 0.1 Morgans apart. If everything went as expected, we should find a recombination frequency near to this value. loc_A &lt;- &#39;loc_02&#39; loc_B &lt;- &#39;loc_03&#39; After specifying the loci, the code is actually identical to that for the un-linked example. As such, only the table of values, plot of D as a function of generation, and the model results are shown. .cl-e6421ad0{}.cl-e61de480{font-family:'Arial';font-size:9pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e62b18bc{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e62b765e{width:0.29in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e62b767c{width:0.29in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e62b7686{width:0.29in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}GENpAqApBqBr_eqs_eqt_equ_eqrstuDrDsDtDuDDmax00.500.500.500.500.250.250.250.250.500.000.000.500.25-0.25-0.250.250.251.0010.510.490.510.490.260.250.250.240.480.030.030.460.22-0.22-0.220.220.220.8920.520.480.520.480.270.250.250.230.460.060.060.420.19-0.19-0.190.190.190.7730.520.480.520.480.270.250.250.230.440.080.080.400.17-0.17-0.170.170.170.6840.530.470.530.470.280.250.250.220.430.100.100.370.15-0.15-0.150.150.150.6050.530.470.530.470.280.250.250.220.410.120.120.350.13-0.13-0.130.130.130.53 The complete table of values is shown for the first 5 generations. While there are a lot of numbers there, it can be useful to see them all together, For each generation we can see how the gene frequencies (pA…) are used to calculate the gamtetic equilibrium frequencies (r_eq…). The observed gametic frequencies are then derived from the haplotype data of the simulation. The disequilibrium for each gametic type (Dr…) is then calculated by subtracting the equilibrium from the observed gametic frequencies. Next, total disequilibrium (D) is calculated as Dr * Du = Ds * Dt. Finally, Dmax is calculated as D divided by the lesser of the observed repulsion heterozygote frequencies. In the first 5 generations, the decline in Dmax is clearly less than for the un-linked example. The graphic more clearly illustrates the more gradual reduction in disequilibrium. As a reference, the un-linked model (c = 0.5) was included in the plot. Rather than reaching equilibrium in 5-6 generations, upwards of 25+ generations were required for loci 2 and 3. Linkage between the two loci is clearly present. summary(mod_linked) ## ## Formula: Dmax ~ 1 * (1 - c)^GEN ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## c 0.103889 0.002805 37.04 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.04227 on 30 degrees of freedom ## ## Number of iterations to convergence: 8 ## Achieved convergence tolerance: 2.359e-06 As was the case for the un-linked model, the linked model also demonstrated a highly significant fit. An estimated recombination frequency of c = 0.111 was also very close to our anticipated value of 0.1. The two loci are clearly in linkage disequilibrium. 2.6 Conclusion While the exercise was developed as a demonstration of disequilibrium and the derivation of its magnitude, it also indirectly validated the AlphaSimR software. AlphaSimR is indeed an extremely useful program to practitioners of population and quantitative genetics. In fact, we will make use of it throughout the entire course. As such, take a long look at the code behind the operations and run a few experiments yourself. First try a few different loci combinations and see if the recombination frequency aligns with the map distance In Morgans. If you’re more ambitious, change the population size and see how this effects the results (NB: model error). As alluded to previously, population size will be a re-occurring theme throughout the course so there is no time like the present to get started! "],["random-drift-in-the-idealized-population.html", "Chapter 3 Random drift in the idealized population 3.1 Introduction 3.2 Flexible parameters 3.3 Making a For Loop 3.4 Plotting the results 3.5 Conclusion", " Chapter 3 Random drift in the idealized population 3.1 Introduction This exercise makes use of equation 3.1 to produce a series of figures depicting random drift. The code is written such that key parameters can be changed and the results observed. Only the tidyverse library is used for the exercise. flextable was used for generating the tables in Rmarkdown. library(flextable) library(tidyverse) 3.2 Flexible parameters If we look closely at Figure 3.1 and Equation 3.1 we can devise a set of parameters whose effects will be interesting to explore. Both axis of the figure, generation and q frequency, are obvious choices. Population size and the number of lines might also prove interesting. These parameters with general starting values are defined as variables below. generations &lt;- 20 q_0 &lt;- 0.5 pop_size &lt;- 100 lines &lt;- 10 The challenge is a little more complex than simply substituting values into equation 3.1. One must remember that we can only predict the magnitude of the change in gene frequency and not the direction. As such, we need to step the lines forward through each generation using the results of the previous generation. A for loop will help us do this. 3.3 Making a For Loop Before starting the for loop we need to make a data frame to store the data. For each line, a data frame of 7x columns and as many rows as generations defined in the parameters (NB: initially 20). The gen column provides the generation number. q_0 and p_0 provide the gene frequencies. N equates to the population size of each line. The variance, var, standard deviation, sd, and the change in gene frequency, diff, columns are calculated fields that will be filled in by the for loop. The first few columns of the data frame are shown for reference. Zero values have yet to be determined. .cl-e7260a7e{}.cl-e7091644{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e71426ce{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e7145f72{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e7145f7c{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e7145f86{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}genq_0p_0Nvarsddiff00.50.510000010.50.510000020.50.510000030.50.510000040.50.510000050.50.5100000 Data frame setup and the for loop are nested inside a function names random_drift. The function accepts a vector of population sizes, N, as input, and produces the complete data frame described earlier. For reference, the code is provided below. The data frame, df, is first written. The for loop is then specified to run from 1 to the number of generations + 1. The extra generation is added to accommodate the base, or 0, generation. The for loop begins with a few if functions. The first if function updates the frequency of q_0 for every generation other than the 0 generation. If generation is greater than 0 then q_0 is adjusted based on the change in gene frequency determined in the preceding generation. The second and third if functions handle the loss or fixation of the q allele should this occur through random drift. Once the calculated frequency of q either goes below 0 or above 1, the frequency will remain at either 0 or 1 in the line. After the if functions, p_0 is calculated as (1 - q_0) in line 4. This is important since q_0 is re-written for every generation above 0. The variance of the change in gene frequency using equation 3.2 is then calculated in line 5. Next, the standard deviation is derived from the variance in line 6. Finally, the predicted change in gene frequency is modeled in line 7. Since dispersive processes have no direction, and the calculated variance is not a measure of magnitude for a single line, the prediction takes advantage of the base R function, rnorm. The function pulls a defined number of samples from a normal distribution with a specified mean and standard deviation. For our purposes, a single sample is drawn from a normal distribution with a mean of 0 and a standard deviation equating to the variance of gene frequencies in the current generation. Because a mean of 0 is used, the predicted change in frequency can be negative or positive. The prediction is written to the diff column where it can be used to adjust the frequency of q in the following generation. The return(df) function specifies the desired output from the random_drift function. random_drift &lt;- function(pop_size){ df &lt;- data.frame(gen = 0:generations, q_0 = q_0, p_0 = 0, N = pop_size, var = 0, sd = 0, diff = 0) for(i in 1:(generations+1)){ if(df$gen[i] &gt; 0){df$q_0[i] &lt;- df$q_0[i-1] + df$diff[i-1]} # line 1 if(df$q_0[i] &lt;= 0) {df$q_0[i] &lt;- 0} # line 2 if(df$q_0[i] &gt;= 1) {df$q_0[i] &lt;- 1} # line 3 df$p_0[i] &lt;- 1 - df$q_0[i] # line 4 df$var[i] &lt;- df$q_0[i] * df$p_0[i] / (2 * df$N[i]) # line 5 df$sd[i] &lt;- (df$var[i])^0.5 # line 6 df$diff[i] &lt;- rnorm(1, mean = 0, sd = df$sd[i]) # line 7 } return(df) } The following code runs the function. An lapply function is used to run random_drift for the population size and number of lines specified. The rbind within a do.call function simply takes all the data frame outputs and binds them into a single data frame. That last bit of code simply adds a line identification number for graphing purposes. df &lt;- do.call(rbind, lapply(rep(pop_size, lines), FUN = random_drift)) %&gt;% mutate(line = rep(1:lines, each = generations + 1)) Data pertaining to the first line is shown below. One can see how the for loop builds out the data from generation 0 onward. Starting at the specified gene frequency, the variance is calculated and the change in gene frequency is predicted. The prediction is then applied to the next generation and the calculations repeated. .cl-e7b0141c{}.cl-e78b5f3c{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e79cbac0{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e79d039a{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e79d03ae{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e79d03b8{width:0.4in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}genq_0p_0Nvarsddiffline00.50000000.50000001000.0012500000.035355340.076437315110.57643730.42356271000.0012207870.034939760.016335147120.59277250.40722751000.0012069660.03474142-0.015529350130.57724310.42275691000.0012201680.03493090-0.033393182140.54384990.45615011000.0012403860.035219110.024945990150.56879590.43120411000.0012263360.03501907-0.005642903160.56315300.43684701000.0012300580.03507219-0.002123918170.56102910.43897091000.0012313770.035090990.011028945180.57205800.42794201000.0012240380.03498626-0.046737566190.52532050.47467951000.0012467940.03530998-0.0657456501100.45957480.54042521000.0012418290.03523959-0.0232027091110.43637210.56362791000.0012297570.035067900.0138145171120.45018660.54981341000.0012375930.035179440.0580768941130.50826350.49173651000.0012496590.035350510.0344706451140.54273420.45726581000.0012408690.03522597-0.0030206571150.53971350.46028651000.0012421140.035243640.0978574701160.63757100.36242901000.0011553710.033990750.0217172621170.65928830.34071171000.0011231360.03351323-0.0032296961180.65605860.34394141000.0011282290.03358911-0.0248453571190.63121320.36878681000.0011639150.034116210.0197654291200.65097860.34902141000.0011360270.033705000.0117930781 3.4 Plotting the results The following code produces a plot similar to Figure 3.1. The base population q frequency is shown as a dashed line. Each line is given a different color. The biggest difference between the plot and Figure 3.1 is the lack of selection in the simulation. df %&gt;% mutate(line = factor(line)) %&gt;% ggplot() + geom_line(aes(x = gen, y = q_0, group = line, color = line), linewidth = 0.75) + scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) + scale_x_continuous(limits = c(0, generations), breaks = seq(0, generations, by = 1)) + geom_hline(yintercept = 0.5, linewidth = 0.75, color = &#39;black&#39;, linetype = &#39;dashed&#39;) + xlab(&#39;generation&#39;) + ylab(&#39;frequency of q allele&#39;) + theme_bw() + theme(legend.position = &quot;none&quot;) 3.5 Conclusion With an understanding of how the simulation works, alter the starting patterns and observe the change in results. If you were really ambitious, the code is a good starting point for an interactive Rshiny app. We’ll be revisiting all these topics in fuutre exercises. "],["systems-of-close-inbreeding.html", "Chapter 4 Systems of close inbreeding 4.1 Introduction 4.2 Through the recurrence equation 4.3 Through coancestry 4.4 Conclusion", " Chapter 4 Systems of close inbreeding 4.1 Introduction Systems of close inbreeding were devised to increase the overall homozygocity of individuals over successive generations. Falconer &amp; Mackay describe several of the most common form of close inbreeding and present recurrence equations for determining the level of inbreeding as a function of generation from the base population. Here, we create a “proof” of the recurrence equations by also determining the accumulation of inbreeding through coancestry. Full sib matings are used as an example here such that you can explore other systems of close inbreeding on your own time. 4.2 Through the recurrence equation The reccurence equation for full sib mating (5.9) is: \\[ F_t=\\frac{1}{4}(1+2F_{t-1}+F_{t-2}) \\] The following script employs a for loop to walk forward through 20 generations of full sib mating. A data frame with columns for generation (t) and inbreeding (Fx) is first defined to store the results of the for loop. Starting at generation 1 (i=2) and working toward generation 20 (i=21), t and Fx are applied to the recurrence equation. A plot of accumulated inbreeding as a function of generation is then produced for reference. The first few lines of the data frame are also shown for comparison with Table 5.1 in the text. df &lt;- data.frame(t = 0:20, Fx = 0) for(i in 2:21){ ifelse(df$t[i] == 1, df$Fx[i] &lt;- 1/4*(1 + 2*df$Fx[i-1]), df$Fx[i] &lt;- 1/4*(1 + 2*df$Fx[i-1] + df$Fx[i-2])) } df %&gt;% ggplot() + geom_line(aes(x = t, y = Fx), color = &quot;navy&quot;, linetype = &quot;dotted&quot;, linewidth = 0.5) + geom_point(aes(x = t, y = Fx), color = &quot;navy&quot;, shape = 1, size = 2.5, stroke = 1) + scale_x_continuous(breaks = seq(0, 20, by = 1)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + xlab(&quot;generations&quot;) + ylab(&quot;inbreeding (F)&quot;) + theme_bw() .cl-ea13e350{}.cl-e9f25a82{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e9fcf474{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e9fd381c{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e9fd3826{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e9fd3830{width:0.5in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}tFx00.000000010.250000020.375000030.500000040.593750050.671875060.734375070.785156280.826171990.8593750 4.3 Through coancestry In the last exercise we learned how to make a kinship matrix. We can now apply that exercise to the calculation of inbreeding (F) over repeated generations of full sib mating. 4.3.1 Develop a pedigree and kinship matrix We need to first develop a pedigree file describing the full sib mating system. While this can be done in R, I often find this easier to do in a spreadsheet program like Google sheets. Using Figure 5.5 from the text, I drew up the first few generations of full sib mating using numerically ascending identification numbers. From the sketch, a sheet with columns for id, sire, dam, sex, and generation. A generation column is not needed for kinship2 but is handy in both setting up the pedigree and graphing the computed inbreeding later on. Coding the pedigree is performed by starting with individual 1 and entering the identification numbers of their male (sire) and female (dam) parents, and their sex. For individual in the base population, parental values of 0 are entered. The first few generations of the sketched and coded pedigree are shown below. With the first 2x generations coded, recursive equations were written in sheets to extend the pedigree to 21 generations. With the pedigree file made in sheets, the googlesheets4 package was used to read the file and convert it to a data frame. This is actually a very handy function for working between spreadsheets and R. In fact, the spreadsheet almost acts as a simple general user interface (GUI) for entering data into R. Note, however, that the data doesn’t automatically update, but will need to be re-read through R. The only challenges one might encounter in using the googlesheets4 package have to do with security tokens. If you have any problems, check Stack Overflow for resolutions. Once the pedigree file is in R, its applied to the pedigree function from the kinship2 package for formatting. The kinship2 package also includes pedigree plotting features. the following script trims the pedigree to three generations before subjecting it to the plot.pedigree function. The resulting pedigree displays the mating scheme with males as squares and females as circles. Large pedigrees can quickly become overwhelming but its a nice feature for illustrating specific mating systems such as those classified as close inbreeding. ped_trim &lt;- ped_df %&gt;% filter(t &lt; 3) ped_trim &lt;- pedigree(id = ped_trim$id, dadid = ped_trim$sire, momid = ped_trim$dam, sex = ped_trim$sex, missid = 0) plot.pedigree(ped_trim, packed = FALSE, align = TRUE, cex = 0.75) The kinship function is used to develop a kinship matrix. A kinship matrix has same row x column dimensions as the number of individuals in the pedigree. Like pedigrees, they can also quickly become overwhelming. The first 10 rows and columns of our full sib kinship matrix is shown below for reference. It’s important to remember that each value of the matrix not only corresponds to the coancestry (f) between the parents indicated by the row &amp; column numbers, but also to the coefficient of inbreeding (F) of their offspring. kinship(ped_ks)[1:10,1:10] ## 1 2 3 4 5 6 7 8 9 10 ## 1 0.50 0.00 0.250 0.250 0.250 0.250 0.25000 0.25000 0.25000 0.25000 ## 2 0.00 0.50 0.250 0.250 0.250 0.250 0.25000 0.25000 0.25000 0.25000 ## 3 0.25 0.25 0.500 0.250 0.375 0.375 0.37500 0.37500 0.37500 0.37500 ## 4 0.25 0.25 0.250 0.500 0.375 0.375 0.37500 0.37500 0.37500 0.37500 ## 5 0.25 0.25 0.375 0.375 0.625 0.375 0.50000 0.50000 0.50000 0.50000 ## 6 0.25 0.25 0.375 0.375 0.375 0.625 0.50000 0.50000 0.50000 0.50000 ## 7 0.25 0.25 0.375 0.375 0.500 0.500 0.68750 0.50000 0.59375 0.59375 ## 8 0.25 0.25 0.375 0.375 0.500 0.500 0.50000 0.68750 0.59375 0.59375 ## 9 0.25 0.25 0.375 0.375 0.500 0.500 0.59375 0.59375 0.75000 0.59375 ## 10 0.25 0.25 0.375 0.375 0.500 0.500 0.59375 0.59375 0.59375 0.75000 4.3.2 Merge the pedigree and kinship matrix If the kinship matrix is converted to a data frame, it can then be converted to a 3-column long format data frame with columns for id, sire, and dam. If this data frame is then merged to the original pedigree file using right_join and by sire and dam, a column equating to the coancestry (f) of the sire-dam combination is added. By definition, this column also equates to the inbreeding coefficient (F) of the individual. The following code completed this operation and then goes a step further for the exercise at hand. First, the generation number (t) is reduced by 1 since F rather than f is being considered. Second, the average inbreeding coefficient per generation is calculated. These two changes permit direct comparison for the recurrence equation. df_coa &lt;- data.frame(kinship(ped_ks)) %&gt;% set_names(., nm = ped_df$id) %&gt;% mutate(sire = 1:length(ped_df$id)) %&gt;% gather(key = &quot;dam&quot;, value = &quot;f&quot;, - c(sire)) %&gt;% mutate(sire = as.numeric(sire), dam = as.numeric(dam)) %&gt;% right_join(., ped_df, by = c(&quot;sire&quot;, &quot;dam&quot;)) %&gt;% select(t, id, sire, dam, f) %&gt;% arrange(id) %&gt;% mutate(t = as.numeric(t) - 1) %&gt;% # this converts f to F group_by(t) %&gt;% summarize(Ft = mean(f)) %&gt;% na.omit() 4.3.3 Compare with the recurrence equation An overlay plot of the recurrence equation on coancestry is shown below. The two methods produce the same result without any error. Full sib inbreeding is straight forward in that there are no alternative mating designs. This is also the case for the offspring-parent and repeated backcross systems. Half sib mating is more complex in that a number of mating designs employing 3-4 parents result in half-sibs but also result in ancillary full sibs. As such, identifying the mating design that best corresponds to the recurrence equation might take some experimentation. df_coa %&gt;% merge(., df, by = &quot;t&quot;) %&gt;% gather(key = &quot;method&quot;, value = &quot;value&quot;, -t) %&gt;% mutate(method = case_when(method == &quot;Ft&quot; ~ &quot;coancestry&quot;, method == &quot;Fx&quot; ~ &quot;recurrence&quot;)) %&gt;% ggplot() + geom_line(aes(x = t, y = value, group = method, color = method), linetype = &quot;dotted&quot;, linewidth = 0.5) + geom_point(aes(x = t, y = value, shape = method, color = method), size = 2.5, stroke = 1) + scale_shape_manual(values = c(1,4)) + scale_color_manual(values = c(&quot;lightblue&quot;, &quot;navy&quot;)) + scale_x_continuous(breaks = seq(0, 20, by = 1)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + xlab(&quot;generations&quot;) + ylab(&quot;inbreeding (F)&quot;) + theme_bw() 4.4 Conclusion With only minor changes, the scripts can be applied to the other systems of close inbreeding in the text with the exception of self-fertilization, which seemingly can’t be handled in kinship2. Performing this on your own time will help you better understand the relationship between pedigree illustrations and pedigree files. It will also reinforce the relationship between the coancestry of parents and the inbreeding coefficient of offspring, and provide a method for calculating generational inbreeding from individual coefficients. "],["change-of-base.html", "Chapter 5 Change of base 5.1 Introduction 5.2 Development of the base population 5.3 Breed from A-to-B &amp; from B-to-X 5.4 Get the complete A-to-X pedigree 5.5 Calculate inbreeding for A-to-B &amp; B-to-X 5.6 Mathematical change of base population 5.7 Confirm the derived result with actual results 5.8 Conclusion", " Chapter 5 Change of base 5.1 Introduction This exercise follows directly on with example 5.2. The problem pertains to changing the base population to which a specific generation of individuals is referenced. Figure 5.8 is presented below. Briefly, the inbreeding of population X was initially determined in reference to population B. However, by knowing the inbreeding of population B relative to A, we can change the base of population X from B to A. Th example problem is relatively straightforward. Here, we perform a proof of the underlying principles by performing a simulation using AlphaSimR. The proof involves first performing a simulation covering populations A-to-X. Next, the accumulation of inbreeding for A-to-B and B-to-X are assessed separately. The change of base if then determined mathematically using equation 5.17. Finally, inbreeding accumulation from A-to-X will be examined to check the results of changing base populations. This exercise requires both the kinship2 and AlphaSimR packages. tidyverse tools are used for general data wrangling and presentation. library(AlphaSimR) library(flextable) library(kinship2) library(tidyverse) 5.2 Development of the base population To start the simulation a base population needs to be developed. Of all the simulations performed in the manual, this one probably has the least important base population. the reason being that all downstream calculations are based on the pedigree itself, rather than anything related to gene frequencies. As such, a single chromosome with 10 segregation sites produced using quickhaplo will produce the same results as an in silico copy of the mouse genome with ten thousand generations of burn-in. Example 5.2 specifies 42 generations of breeding at an effective population size of 40 (NB: from A-to-B), followed by a further 11 generations of full-sib mating (NB: from B-to-X). Any number of mating schemes could be used to go from A-to-B but the minimal inbreeding strategy common to laboratory animal, and describe in Chapter 4, is the easiest to envision. For minimal inbreeding N_e = 2N-1. As such, a base population with 20 individuals provides an N_e of just about 40. Sexes are specified to make the simulation easily compatible with the kinship2 package. The following code develops base population A. n_pop &lt;- 20 pop_haps &lt;- quickHaplo(nInd = n_pop, nChr = 1, segSites = 10, genLen = 1, ploidy = 2L, inbred = FALSE) SP = SimParam$new(pop_haps) SP$setSexes(&quot;yes_sys&quot;) pop_0 &lt;- newPop(rawPop = pop_haps, simParam = SP) 5.3 Breed from A-to-B &amp; from B-to-X Prior to breeding, a vector list was developed to hold the populations created by a for loop and the base population stored. The first loop employs the randCross function to perform 10 crosses each producing 2 progeny. In this way, the individuals of each generation are replaced by their offspring and an N_e of near 40 is maintained. Full-sib mating commences at generation 42. The function makeCross is used to perform the full-sib mating according to the previously defined cross plan. In this case, the cross plan takes advantage of the sequential and predictable enumeration of individuals in AlphaSimR. For each generation, individual IDs are used to fill a 2-column matrix row-wise. In this way, the matrix is composed of rows of brother-sister combinations. We only need to switch the column order to sister-brother to conform with the cross plan structure. With the logical organization of AlphaSimR, repeating the cross plan over a series of generations results in 10 separate full-sib lines. POP &lt;- vector(length = 55, mode = &quot;list&quot;) POP[[1]] &lt;- pop_0 for(i in 2:43){ POP[[i]] &lt;- randCross(pop = POP[[i - 1]], nCrosses = 10, nProgeny = 2, simParam = SP) } for(i in 44:55){ cp &lt;- matrix(data = POP[[i-1]]@id, ncol = 2, byrow = TRUE) cp &lt;- cbind(cp[,2], cp[,1]) POP[[i]] &lt;- makeCross(pop = POP[[i-1]], crossPlan = cp, nProgeny = 2, simParam = SP) } 5.4 Get the complete A-to-X pedigree A function was first developed to pull and format the pedigree as a data frame from a single population. The do.call and lapply functions were then used to pull and combine the pedigrees from all populations. The first and last 5 entries in the pedigree are shown for interest. Note that both sex and generation (t) were added to the pedigree. While sex permits easy integration with kinship2, generation facilitates data wrangling and presentation later on. full_ped &lt;- function(gen){ getPed(POP[[gen]]) %&gt;% mutate(t = gen-1) %&gt;% mutate(sex = POP[[gen]]@sex) %&gt;% mutate(id = as.numeric(id), sire = as.numeric(father), dam = as.numeric(mother)) %&gt;% select(t, id, sire, dam, sex) } ped_df &lt;- do.call(rbind, lapply(1:55, FUN = full_ped)) .cl-f5eb4c18{}.cl-f5cc1096{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-f5d93a1e{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-f5d98780{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f5d987a8{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f5d987b2{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}tidsiredamsex0100M0200F0300M0400F0500M541,0961,0751,076F541,0971,0771,078M541,0981,0771,078F541,0991,0791,080M541,1001,0791,080F 5.5 Calculate inbreeding for A-to-B &amp; B-to-X For the purpose of the exercise, we will first examine the pedigrees separately from A-to-B and B-to-X. The following code simply filters the pedigree to generations less than 42 before formatting using the pedigree function from kinship2. With the pedigree formatted, the kinship function is applied, the resulting matrix converted to a long-format data frame, merging with the original pedigree file, and calculating the mean coefficient of inbreeding (F) for each generation. For more details on this process, revisit the preceding exercise comparing recurrence equations and coancestry. Because this is a simulation, variance exists in the calculated inbreeding from generation-to-generation. To compensate for this variation, a linear model in the form of F = b + mt is fit to the data. A plot of inbreeding as a function of time is then produced so the results can be examined. After 42 generations, inbreeding reaches a level of just over 0.4. This equates well to the theoretical value of 0.410 reported in the example problem. ped_AB &lt;- ped_df %&gt;% filter(t &lt; 43) ped_ks &lt;- pedigree(id = ped_AB$id, dadid = ped_AB$sire, momid = ped_AB$dam, sex = ped_AB$sex, missid = 0) df_AB &lt;- data.frame(kinship(ped_ks)) %&gt;% set_names(., nm = ped_ks$id) %&gt;% mutate(sire = 1:length(ped_ks$id)) %&gt;% gather(key = &quot;dam&quot;, value = &quot;f&quot;, - c(sire)) %&gt;% mutate(sire = as.numeric(sire), dam = as.numeric(dam)) %&gt;% right_join(., ped_AB, by = c(&quot;sire&quot;, &quot;dam&quot;)) %&gt;% select(t, id, sire, dam, f) %&gt;% arrange(id) %&gt;% group_by(t) %&gt;% summarize(Ft = mean(f)) %&gt;% mutate(Ft = ifelse(is.na(Ft) == TRUE, 0, Ft)) mod_AB &lt;- lm(Ft~t, data = df_AB) df_AB %&gt;% ggplot() + geom_line(aes(x = t, y = Ft), color = &quot;navy&quot;, linetype = &quot;dotted&quot;, linewidth = 0.5) + geom_point(aes(x = t, y = Ft), color = &quot;navy&quot;, shape = 1, size = 2.5, stroke = 1) + geom_line(aes(x = t, y = predict(mod_AB)), color = &quot;black&quot;, linewidth = 0.75) + scale_x_continuous(breaks = seq(0, 60, by = 2)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + xlab(&quot;generations&quot;) + ylab(&quot;inbreeding (F)&quot;) + theme_bw() The same basic processes are applied to generations 42 to 54 that represent the progression from B-to-X. The only difference between the scripts are a few lines of code to revert the filtered pedigree IDs to start from 1. After 11 generations of full-sib mating, inbreeding reaches a level equal to 0.908. This is equivalent to the theoretical value given in the example problem, and in table 5.1. ped_BX &lt;- ped_df %&gt;% filter(t &gt; 41) %&gt;% mutate(id = id - 840) %&gt;% mutate(sire = ifelse(sire - 840 &lt; 0, 0, sire - 840)) %&gt;% mutate(dam = ifelse(dam - 840 &lt; 0, 0, dam - 840)) ped_ks &lt;- pedigree(id = ped_BX$id, dadid = ped_BX$sire, momid = ped_BX$dam, sex = ped_BX$sex, missid = 0) df_BX &lt;- data.frame(kinship(ped_ks)) %&gt;% set_names(., nm = ped_ks$id) %&gt;% mutate(sire = 1:length(ped_ks$id)) %&gt;% gather(key = &quot;dam&quot;, value = &quot;f&quot;, - c(sire)) %&gt;% mutate(sire = as.numeric(sire), dam = as.numeric(dam)) %&gt;% right_join(., ped_BX, by = c(&quot;sire&quot;, &quot;dam&quot;)) %&gt;% select(t, id, sire, dam, f) %&gt;% arrange(id) %&gt;% group_by(t) %&gt;% summarize(Ft = mean(f)) %&gt;% mutate(Ft = ifelse(is.na(Ft) == TRUE, 0, Ft)) df_BX %&gt;% ggplot() + geom_line(aes(x = t, y = Ft), color = &quot;navy&quot;, linetype = &quot;dotted&quot;, linewidth = 0.5) + geom_point(aes(x = t, y = Ft), color = &quot;navy&quot;, shape = 1, size = 2.5, stroke = 1) + scale_x_continuous(breaks = seq(0, 60, by = 1)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + xlab(&quot;generations&quot;) + ylab(&quot;inbreeding (F)&quot;) + theme_bw() 5.6 Mathematical change of base population With the accumulation of inbreeding determined for the progression from A-to-B and B-to-X, it is only a matter of applying equation 5.17 to derive the relationship for progression from A-to-X. For the first 42 generations, the model is used to estimate F_B-A. Since there is no variation in the measure, F_X-B is acquired directly from generation 54. Equation 5.17 results in the panmictic index (P_X-A). To convert to F_X-A one simply needs to subtract the panmictic index from 1. The results will vary a bit because its a stochastic simulation but should be fairly close to the F = 0.946 value reported in the example problem. b &lt;- as.numeric(mod_AB$coefficients[1]) m &lt;- as.numeric(mod_AB$coefficients[2]) F_BA &lt;- b + m*42 F_XB &lt;- df_BX %&gt;% filter(t == 54) %&gt;% pull(Ft) P_XA &lt;- (1-F_XB)*(1-F_BA) F_XA_cob &lt;- (1-P_XA) .cl-f8e1a7be{}.cl-f8c35282{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-f8cf5f00{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-f8cf9e20{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f8cf9e34{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}parametervalueF_XA_cob0.9479834 5.7 Confirm the derived result with actual results Rather than confirming the results of the book, here we are interested in demonstrating that the mathematical change of base population is equal to the actual accumulation of inbreeding for the progression from A-to-X. To determine this value can extend the preceding analysis to the entire pedigree from generations 0 to 54. A plot of F as a function of generation illustrates the accumulation of inbreeding throughout both the random and full-sib breeding phases. ped_ks &lt;- pedigree(id = ped_df$id, dadid = ped_df$sire, momid = ped_df$dam, sex = ped_df$sex, missid = 0) df_XA &lt;- data.frame(kinship(ped_ks)) %&gt;% set_names(., nm = ped_df$id) %&gt;% mutate(sire = 1:length(ped_df$id)) %&gt;% gather(key = &quot;dam&quot;, value = &quot;f&quot;, - c(sire)) %&gt;% mutate(sire = as.numeric(sire), dam = as.numeric(dam)) %&gt;% right_join(., ped_df, by = c(&quot;sire&quot;, &quot;dam&quot;)) %&gt;% select(t, id, sire, dam, f) %&gt;% arrange(id) %&gt;% group_by(t) %&gt;% summarize(Ft = mean(f)) %&gt;% mutate(Ft = ifelse(is.na(Ft) == TRUE, 0, Ft)) df_XA %&gt;% ggplot() + geom_line(aes(x = t, y = Ft), color = &quot;navy&quot;, linetype = &quot;dotted&quot;, linewidth = 0.5) + geom_point(aes(x = t, y = Ft), color = &quot;navy&quot;, shape = 1, size = 2.5, stroke = 1) + scale_x_continuous(breaks = seq(0, 60, by = 2)) + scale_y_continuous(breaks = seq(0, 1, by = 0.1)) + xlab(&quot;generations&quot;) + ylab(&quot;inbreeding (F)&quot;) + theme_bw() 5.8 Conclusion A direct comparison of the actual and derived results demonstrates nearly identical inbreeding coefficients. As such, support for the underlying theory behind changes of base population has been provided through simulation. As an interesting next step, one might re-develop the base population and calculate F through measures of gene frequency. Would the same results be achieved? Would the difference between the derived and actual measures of F be the same? .cl-fc8b3006{}.cl-fc6adbbc{font-family:'Arial';font-size:10pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-fc75b17c{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-fc75f114{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-fc75f128{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-fc75f13c{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}parametervalueF_XA_cob0.9479834F_XA_actual0.9465934 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
